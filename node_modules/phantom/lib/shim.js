"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _webpage = require("webpage");

var _webpage2 = _interopRequireDefault(_webpage);

var _system = require("system");

var _system2 = _interopRequireDefault(_system);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Stores all all pages and single instance of phantom
 */
var objectSpace = {
    phantom: phantom
};

/**
 * All methods that have a callback in their signature
 * @type {string[]}
 */
var haveCallbacks = ['open', 'includeJs'];

/**
 * All commands that have a custom implementation
 */
var commands = {
    createPage: function createPage(command) {
        var page = _webpage2.default.create();
        objectSpace['page$' + command.id] = page;

        page.onClosing = function () {
            return delete objectSpace['page$' + command.id];
        };

        command.response = { pageId: command.id };
        completeCommand(command);
    },
    property: function property(command) {
        if (command.params.length > 1) {
            if (typeof command.params[1] === 'function') {
                (function () {
                    // If the second parameter is a function then we want to proxy and pass parameters too
                    var callback = command.params[1];
                    var args = command.params.slice(2);
                    args.forEach(function (param) {
                        if (param.target !== undefined) {
                            objectSpace[param.target] = param;
                        }
                    });
                    objectSpace[command.target][command.params[0]] = function () {
                        var params = [].slice.call(arguments).concat(args);
                        return callback.apply(objectSpace[command.target], params);
                    };
                })();
            } else {
                // If the second parameter is not a function then just assign
                objectSpace[command.target][command.params[0]] = command.params[1];
            }
        } else {
            command.response = objectSpace[command.target][command.params[0]];
        }

        completeCommand(command);
    },
    setting: function setting(command) {
        if (command.params.length === 2) {
            objectSpace[command.target].settings[command.params[0]] = command.params[1];
        } else {
            command.response = objectSpace[command.target].settings[command.params[0]];
        }

        completeCommand(command);
    },

    windowProperty: function windowProperty(command) {
        if (command.params.length === 2) {
            window[command.params[0]] = command.params[1];
        } else {
            command.response = window[command.params[0]];
        }
        completeCommand(command);
    },

    noop: function noop(command) {
        return completeCommand(command);
    }
};

/**
 * Calls readLine() and blocks until a message is ready
 */
function read() {
    var line = _system2.default.stdin.readLine();
    if (line) {
        var command = JSON.parse(line, function (key, value) {
            if (value && typeof value === 'string' && value.substr(0, 8) === 'function' && value.indexOf('[native code]') === -1) {
                var startBody = value.indexOf('{') + 1;
                var endBody = value.lastIndexOf('}');
                var startArgs = value.indexOf('(') + 1;
                var endArgs = value.indexOf(')');
                return new Function(value.substring(startArgs, endArgs), value.substring(startBody, endBody));
            }
            return value;
        });

        // Call here to look for transform key
        transform(command.params);

        try {
            executeCommand(command);
        } catch (e) {
            command.error = e.message;
            completeCommand(command);
        }
    }
}

/**
 * Looks for transform key and uses objectSpace to call objects
 * @param object
 */
function transform(object) {
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            var child = object[key];
            if (child.transform === true) {
                object[key] = objectSpace[child.parent][child.method](child.target);
            } else if ((typeof child === "undefined" ? "undefined" : _typeof(child)) === 'object') {
                transform(child);
            }
        }
    }
}

/**
 * Executes a command by first checking if it is a custom method and then calling the method on the target.
 * @param command the command to execute
 */
function executeCommand(command) {
    if (commands[command.name]) {
        return commands[command.name](command);
    } else if (objectSpace[command.target]) {
        var target = objectSpace[command.target];
        var method = target[command.name];

        if (haveCallbacks.indexOf(command.name) === -1) {
            command.response = method.apply(target, command.params);
            completeCommand(command);
        } else {
            var params = command.params.slice(); // copy params
            params.push(function (status) {
                command.response = status;
                completeCommand(command);
            });
            method.apply(target, params);
        }
    } else {
        throw new Error("Cannot find " + command.name + " method to execute on " + command.target + " object.");
    }
}

/**
 * Completes a command by return a response to node and listening again for next command.
 * @param command
 */
function completeCommand(command) {
    _system2.default.stdout.writeLine('>' + JSON.stringify(command));
    // Prevent event-queue from clogging up by reads that block.
    setTimeout(read, 0);
}

read();